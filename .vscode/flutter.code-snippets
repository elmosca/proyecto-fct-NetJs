{
    // ========================================
    // SNIPPETS BASADOS EN REGLAS FLUTTER.MDC
    // ========================================
    "Flutter StatelessWidget con Clean Architecture": {
        "prefix": "flsw",
        "body": [
            "/// ${1:Descripción del widget}",
            "class ${2:WidgetName} extends StatelessWidget {",
            "  const ${2:WidgetName}({super.key});",
            "",
            "  @override",
            "  Widget build(BuildContext context) {",
            "    return ${3:Container}();",
            "  }",
            "}"
        ],
        "description": "Crea un StatelessWidget siguiendo las convenciones establecidas"
    },
    "Flutter StatefulWidget con Clean Architecture": {
        "prefix": "flstw",
        "body": [
            "/// ${1:Descripción del widget}",
            "class ${2:WidgetName} extends StatefulWidget {",
            "  const ${2:WidgetName}({super.key});",
            "",
            "  @override",
            "  State<${2:WidgetName}> createState() => _${2:WidgetName}State();",
            "}",
            "",
            "class _${2:WidgetName}State extends State<${2:WidgetName}> {",
            "  @override",
            "  Widget build(BuildContext context) {",
            "    return ${3:Container}();",
            "  }",
            "}"
        ],
        "description": "Crea un StatefulWidget siguiendo las convenciones establecidas"
    },
    "Repository Pattern": {
        "prefix": "flrepo",
        "body": [
            "/// Repository para ${1:Entity}",
            "abstract class ${2:Entity}Repository {",
            "  Future<List<${3:EntityModel}>> getAll();",
            "  Future<${3:EntityModel}?> getById(String id);",
            "  Future<${3:EntityModel}> create(${4:CreateEntityDto} dto);",
            "  Future<${3:EntityModel}> update(String id, ${5:UpdateEntityDto} dto);",
            "  Future<void> delete(String id);",
            "}"
        ],
        "description": "Crea un repository siguiendo Clean Architecture"
    },
    "Repository Implementation": {
        "prefix": "flrepoimpl",
        "body": [
            "/// Implementación del repository para ${1:Entity}",
            "class ${2:Entity}RepositoryImpl implements ${2:Entity}Repository {",
            "  const ${2:Entity}RepositoryImpl({",
            "    required this.${3:dataSource},",
            "  });",
            "",
            "  final ${4:DataSource} ${3:dataSource};",
            "",
            "  @override",
            "  Future<List<${5:EntityModel}>> getAll() async {",
            "    try {",
            "      return await ${3:dataSource}.getAll();",
            "    } catch (e) {",
            "      throw RepositoryException('Error al obtener ${1:Entity}s: $e');",
            "    }",
            "  }",
            "",
            "  @override",
            "  Future<${5:EntityModel}?> getById(String id) async {",
            "    try {",
            "      return await ${3:dataSource}.getById(id);",
            "    } catch (e) {",
            "      throw RepositoryException('Error al obtener ${1:Entity}: $e');",
            "    }",
            "  }",
            "",
            "  // TODO: Implementar resto de métodos",
            "}"
        ],
        "description": "Implementación de repository con manejo de errores"
    },
    "Service Class": {
        "prefix": "flservice",
        "body": [
            "/// Servicio para ${1:Domain}",
            "@injectable",
            "class ${2:Domain}Service {",
            "  const ${2:Domain}Service({",
            "    required this.${3:repository},",
            "  });",
            "",
            "  final ${4:Repository} ${3:repository};",
            "",
            "  Future<Result<List<${5:Model}>>> getAll() async {",
            "    try {",
            "      final List<${5:Model}> items = await ${3:repository}.getAll();",
            "      return Result.success(items);",
            "    } catch (e) {",
            "      return Result.failure(ServiceException('Error en ${2:Domain}Service: $e'));",
            "    }",
            "  }",
            "}"
        ],
        "description": "Crea un servicio siguiendo las convenciones"
    },
    "Controller con Riverpod": {
        "prefix": "flcontroller",
        "body": [
            "/// Controller para ${1:Feature}",
            "@riverpod",
            "class ${2:Feature}Controller extends _$${2:Feature}Controller {",
            "  @override",
            "  ${3:FeatureState} build() {",
            "    return const ${3:FeatureState}.initial();",
            "  }",
            "",
            "  Future<void> ${4:actionName}() async {",
            "    state = const ${3:FeatureState}.loading();",
            "    try {",
            "      final result = await ref.read(${5:serviceProvider}).${4:actionName}();",
            "      result.when(",
            "        success: (data) => state = ${3:FeatureState}.loaded(data),",
            "        failure: (error) => state = ${3:FeatureState}.error(error.message),",
            "      );",
            "    } catch (e) {",
            "      state = ${3:FeatureState}.error('Error inesperado: $e');",
            "    }",
            "  }",
            "}"
        ],
        "description": "Controller con Riverpod y manejo de estados"
    },
    "Test Arrange-Act-Assert": {
        "prefix": "fltest",
        "body": [
            "testWidgets('${1:should_do_something_when_condition}', (WidgetTester tester) async {",
            "  // Arrange",
            "  const ${2:InputType} input${3:Name} = ${4:inputValue};",
            "  const ${5:ExpectedType} expected${6:Name} = ${7:expectedValue};",
            "",
            "  // Act",
            "  ${8:// Ejecutar la acción}",
            "  final ${9:ActualType} actual${10:Name} = ${11:actualValue};",
            "",
            "  // Assert",
            "  expect(actual${10:Name}, equals(expected${6:Name}));",
            "});"
        ],
        "description": "Test con patrón Arrange-Act-Assert"
    },
    "Given-When-Then Test": {
        "prefix": "flgwt",
        "body": [
            "group('${1:Feature}', () {",
            "  testWidgets('${2:should_result_when_action}', (WidgetTester tester) async {",
            "    // Given",
            "    ${3:// Configuración inicial}",
            "",
            "    // When",
            "    ${4:// Acción a ejecutar}",
            "",
            "    // Then",
            "    ${5:// Verificaciones}",
            "  });",
            "});"
        ],
        "description": "Test con patrón Given-When-Then"
    },
    "Freezed Data Class": {
        "prefix": "flfreezed",
        "body": [
            "import 'package:freezed_annotation/freezed_annotation.dart';",
            "",
            "part '${1:filename}.freezed.dart';",
            "part '${1:filename}.g.dart';",
            "",
            "/// ${2:Descripción de la clase}",
            "@freezed",
            "class ${3:ClassName} with _$${3:ClassName} {",
            "  const factory ${3:ClassName}({",
            "    required ${4:String} ${5:property},",
            "  }) = _${3:ClassName};",
            "",
            "  factory ${3:ClassName}.fromJson(Map<String, dynamic> json) =>",
            "      _$${3:ClassName}FromJson(json);",
            "}"
        ],
        "description": "Clase de datos con Freezed"
    },
    "GetIt Registration": {
        "prefix": "flgetit",
        "body": [
            "/// Registro de dependencias para ${1:Module}",
            "void register${2:Module}Dependencies(GetIt getIt) {",
            "  // Repositories",
            "  getIt.registerLazySingleton<${3:Repository}>(",
            "    () => ${4:RepositoryImpl}(${5:dependencies}),",
            "  );",
            "",
            "  // Services",
            "  getIt.registerLazySingleton<${6:Service}>(",
            "    () => ${7:ServiceImpl}(repository: getIt<${3:Repository}>()),",
            "  );",
            "",
            "  // Use Cases",
            "  getIt.registerFactory<${8:UseCase}>(",
            "    () => ${9:UseCaseImpl}(service: getIt<${6:Service}>()),",
            "  );",
            "}"
        ],
        "description": "Registro de dependencias con GetIt"
    },
    "Early Return Pattern": {
        "prefix": "flearlyreturn",
        "body": [
            "if (${1:condition}) {",
            "  return ${2:earlyValue};",
            "}",
            "${3:// Lógica principal}"
        ],
        "description": "Patrón early return para evitar anidación"
    },
    "go_router Route": {
        "prefix": "flroute",
        "body": [
            "/// Ruta para ${1:Feature}",
            "GoRoute(",
            "  path: '/${2:path}',",
            "  name: ${3:RouteName},",
            "  builder: (context, state) => const ${4:WidgetName}(),",
            "  redirect: (context, state) {",
            "    ${5:// Lógica de redirección si es necesaria}",
            "    return null;",
            "  },",
            "),"
        ],
        "description": "Ruta con go_router siguiendo las convenciones"
    },
    "go_router Nested Route": {
        "prefix": "flnestedroute",
        "body": [
            "/// Ruta anidada para ${1:Feature}",
            "ShellRoute(",
            "  builder: (context, state, child) => ${2:LayoutWidget}(child: child),",
            "  routes: [",
            "    GoRoute(",
            "      path: '/${3:path}',",
            "      name: ${4:RouteName},",
            "      builder: (context, state) => const ${5:WidgetName}(),",
            "    ),",
            "  ],",
            "),"
        ],
        "description": "Ruta anidada con go_router"
    },
    "Multiplatform Widget": {
        "prefix": "flmp",
        "body": [
            "/// Widget multiplataforma para ${1:Feature}",
            "class ${2:WidgetName} extends StatelessWidget {",
            "  const ${2:WidgetName}({super.key});",
            "",
            "  @override",
            "  Widget build(BuildContext context) {",
            "    if (kIsWeb) {",
            "      return ${3:WebWidget}();",
            "    } else if (Platform.isAndroid) {",
            "      return ${4:AndroidWidget}();",
            "    } else if (Platform.isIOS) {",
            "      return ${5:IOSWidget}();",
            "    }",
            "    return ${6:DefaultWidget}();",
            "  }",
            "}"
        ],
        "description": "Widget que se adapta a diferentes plataformas"
    },
    "Integration Test": {
        "prefix": "flitest",
        "body": [
            "import 'package:flutter_test/flutter_test.dart';",
            "import 'package:integration_test/integration_test.dart';",
            "import 'package:${1:app_name}/main.dart' as app;",
            "",
            "void main() {",
            "  IntegrationTestWidgetsFlutterBinding.ensureInitialized();",
            "",
            "  group('${2:Feature} Integration Tests', () {",
            "    testWidgets('${3:should_do_something}', (tester) async {",
            "      app.main();",
            "      await tester.pumpAndSettle();",
            "",
            "      // Given",
            "      ${4:// Configuración inicial}",
            "",
            "      // When",
            "      ${5:// Acción a ejecutar}",
            "",
            "      // Then",
            "      ${6:// Verificaciones}",
            "    });",
            "  });",
            "}"
        ],
        "description": "Test de integración completo"
    },
    "Golden Test": {
        "prefix": "flgolden",
        "body": [
            "testWidgets('${1:widget_name} golden test', (WidgetTester tester) async {",
            "  // Arrange",
            "  await tester.pumpWidget(",
            "    MaterialApp(",
            "      home: ${2:WidgetName}(),",
            "    ),",
            "  );",
            "",
            "  // Act",
            "  await tester.pumpAndSettle();",
            "",
            "  // Assert",
            "  await expectLater(",
            "    find.byType(${2:WidgetName}),",
            "    matchesGoldenFile('${3:golden_file_name}.png'),",
            "  );",
            "});"
        ],
        "description": "Test golden para verificar consistencia visual"
    },
    "Provider with Riverpod": {
        "prefix": "flprovider",
        "body": [
            "/// Provider para ${1:Feature}",
            "final ${2:featureProvider} = Provider<${3:Service}>((ref) {",
            "  return ${3:Service}();",
            "});",
            "",
            "/// StateNotifierProvider para ${1:Feature}",
            "final ${4:featureStateProvider} = StateNotifierProvider<${5:Controller}, ${6:State}>((ref) {",
            "  return ${5:Controller}();",
            "});"
        ],
        "description": "Providers con Riverpod"
    },
    "Error Handling": {
        "prefix": "flerror",
        "body": [
            "try {",
            "  ${1:// Código que puede fallar}",
            "} on ${2:ExceptionType} catch (e) {",
            "  ${3:// Manejo específico}",
            "  rethrow;",
            "} catch (e) {",
            "  ${4:// Manejo general}",
            "  throw ${5:CustomException}('${6:Error message}: $e');",
            "}"
        ],
        "description": "Manejo de errores estructurado"
    },
    "Performance Widget": {
        "prefix": "flperf",
        "body": [
            "/// Widget optimizado para performance",
            "class ${1:WidgetName} extends StatelessWidget {",
            "  const ${1:WidgetName}({super.key});",
            "",
            "  @override",
            "  Widget build(BuildContext context) {",
            "    return RepaintBoundary(",
            "      child: ${2:ChildWidget}(),",
            "    );",
            "  }",
            "}"
        ],
        "description": "Widget con optimizaciones de performance"
    }
}